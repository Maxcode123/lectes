{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is lectes?","text":"<p><code>lectes</code> is a scanner generator written in Python; you can use it to easily create a scanner by writing Python code. Head to Usage if you want to know how.</p>"},{"location":"installation/","title":"Installation","text":"<p>Just:</p> <pre><code>pip install lectes\n</code></pre>"},{"location":"scanner/","title":"scanner","text":""},{"location":"scanner/#lectes.scanner.scanner.Scanner","title":"<code>Scanner</code>","text":"<p>Scans a given text and returns tokens based on the provided configuration.</p>"},{"location":"scanner/#lectes.scanner.scanner.Scanner--example","title":"Example","text":"<pre><code>from lectes import Rule, Configuration, Regex, Scanner\n\nconfig = Configuration(\n    [\n        Rule(name=\"FOR\", regex=Regex(\"for\")),\n        Rule(name=\"INT\", regex=Regex(\"[1-9]+\")),\n        Rule(name=\"ID\", regex=Regex(\"[a-zA-Z][a-zA-Z0-9]*\")),\n        Rule(name=\"WHITESPACE\", regex=Regex(\"( )\")),\n    ]\n)\n\nscanner = Scanner(config)\nprogram = \"somevar in othervar for 9 let\"\n\nfor token in scanner.scan(program):\n    print(token)\n</code></pre> Source code in <code>src/lectes/scanner/scanner.py</code> <pre><code>class Scanner:\n    \"\"\"\n    Scans a given text and returns tokens based on the provided configuration.\n\n    ## Example\n\n    ```python\n    from lectes import Rule, Configuration, Regex, Scanner\n\n    config = Configuration(\n        [\n            Rule(name=\"FOR\", regex=Regex(\"for\")),\n            Rule(name=\"INT\", regex=Regex(\"[1-9]+\")),\n            Rule(name=\"ID\", regex=Regex(\"[a-zA-Z][a-zA-Z0-9]*\")),\n            Rule(name=\"WHITESPACE\", regex=Regex(\"( )\")),\n        ]\n    )\n\n    scanner = Scanner(config)\n    program = \"somevar in othervar for 9 let\"\n\n    for token in scanner.scan(program):\n        print(token)\n    ```\n    \"\"\"\n\n    def __init__(self, configuration: Configuration, debug: bool = False) -&gt; None:\n        self.configuration = configuration\n        self.set_text(\"\")\n        self._unmatched_handler = self._handle_unmatched\n        self._matched_handlers = {\n            rule: self._handle_matched for rule in configuration.rules\n        }\n        self._debug = debug\n        self._logger = None\n        self._match = None\n        self._matched_rule = None\n\n    def scan(self, text: str) -&gt; Generator[Token]:\n        \"\"\"\n        Scan the given text and yield tokens as they are recognized.\n        \"\"\"\n        if len(text) == 0:\n            return\n\n        self.set_text(text)\n\n        for character in text:\n            self.logger().debug(f\"character: '{character}'\")\n\n            current_string = self.current_string()\n            self.logger().debug(f\"current_string: '{current_string}'\")\n\n            lookahead_string = self.lookahead_string()\n            self.logger().debug(f\"lookahead_string: '{lookahead_string}'\")\n\n            for rule in self.configuration.rules:\n                if not self._is_last_char() and rule.regex.fullmatch(lookahead_string):\n                    self.logger().debug(\n                        f\"rule {rule.name} fullmatched lookahead_string: '{lookahead_string}'\"\n                    )\n                    break\n\n                if match := rule.regex.search(current_string):\n                    self.logger().debug(\n                        f\"rule {rule.name} matched current_string: '{current_string}'\"\n                    )\n                    self._update_matched_state(rule, match)\n\n            if self._match is not None:\n                if self._match.unmatched is not None:\n                    self._unmatched_handler(self._match.unmatched)\n\n                if self._matched_rule is not None:\n                    result = self._matched_handlers[self._matched_rule](\n                        self._match.string, self._matched_rule\n                    )\n\n                    if result is not None:\n                        yield result\n\n                self.last_position = self.current_position\n\n            self.current_position += 1\n            self._reset_matched_state()\n\n    def set_unmatched_handler(self, handler: Callable[[str], None]) -&gt; None:\n        \"\"\"\n        Set the given function as the handler that executes when a string is not\n        matched to a configured rule.\n\n        The handler receives the string as argument and does returns None.\n        \"\"\"\n        self._unmatched_handler = handler\n\n    def set_handler(self, rule: Rule, handler: Callable[[str, Rule], Any]) -&gt; None:\n        \"\"\"\n        Set the given function as the handler that executes when a string is matched\n        against rule.\n\n        The handler should receive the matched string literal and the rule as arguments.\n        \"\"\"\n        self._matched_handlers[rule] = handler\n\n    def set_text(self, text: str) -&gt; None:\n        \"\"\"\n        Set the text to scan.\n        \"\"\"\n        self.text = text\n        self.current_position = 1\n        self.last_position = 0\n\n    def current_string(self) -&gt; str:\n        \"\"\"\n        Return the string that the scanner is currently reading; that is,\n        the characters from the last matched string up to the character that\n        the scanner is currently reading.\n        \"\"\"\n        return self.text[self.last_position : self.current_position]\n\n    def lookahead_string(self) -&gt; str:\n        \"\"\"\n        Return the string that the scanner is currently reading plus one character.\n        \"\"\"\n        return self.text[self.last_position : self.current_position + 1]\n\n    def logger(self) -&gt; Logger:\n        \"\"\"\n        Return the scanner's logger instance.\n        \"\"\"\n        if self._logger is None:\n            self._logger = self._build_logger()\n\n        return self._logger\n\n    def _build_logger(self) -&gt; Logger:\n        logger = Logger()\n\n        if self._debug:\n            logger.set_level(LogLevel.DEBUG)\n\n        return logger\n\n    def _is_last_char(self) -&gt; bool:\n        return self.current_position == len(self.text)\n\n    def _update_matched_state(self, rule: Rule, match: Match) -&gt; None:\n        if self._match is None or len(match) &gt; len(self._match):\n            self.logger().debug(f\"updating match from {self._match} to {match.string}\")\n            self._matched_rule = rule\n            self._match = match\n\n    def _reset_matched_state(self) -&gt; None:\n        self._match = None\n        self._matched_rule = None\n\n    @staticmethod\n    def _handle_unmatched(unmatched: str) -&gt; None:\n        print(f\"unmatched: {unmatched}\")\n\n    @staticmethod\n    def _handle_matched(matched: str, rule: Rule) -&gt; Token:\n        return Token(rule=rule, literal=matched)\n</code></pre>"},{"location":"scanner/#lectes.scanner.scanner.Scanner.current_string","title":"<code>current_string()</code>","text":"<p>Return the string that the scanner is currently reading; that is, the characters from the last matched string up to the character that the scanner is currently reading.</p> Source code in <code>src/lectes/scanner/scanner.py</code> <pre><code>def current_string(self) -&gt; str:\n    \"\"\"\n    Return the string that the scanner is currently reading; that is,\n    the characters from the last matched string up to the character that\n    the scanner is currently reading.\n    \"\"\"\n    return self.text[self.last_position : self.current_position]\n</code></pre>"},{"location":"scanner/#lectes.scanner.scanner.Scanner.logger","title":"<code>logger()</code>","text":"<p>Return the scanner's logger instance.</p> Source code in <code>src/lectes/scanner/scanner.py</code> <pre><code>def logger(self) -&gt; Logger:\n    \"\"\"\n    Return the scanner's logger instance.\n    \"\"\"\n    if self._logger is None:\n        self._logger = self._build_logger()\n\n    return self._logger\n</code></pre>"},{"location":"scanner/#lectes.scanner.scanner.Scanner.lookahead_string","title":"<code>lookahead_string()</code>","text":"<p>Return the string that the scanner is currently reading plus one character.</p> Source code in <code>src/lectes/scanner/scanner.py</code> <pre><code>def lookahead_string(self) -&gt; str:\n    \"\"\"\n    Return the string that the scanner is currently reading plus one character.\n    \"\"\"\n    return self.text[self.last_position : self.current_position + 1]\n</code></pre>"},{"location":"scanner/#lectes.scanner.scanner.Scanner.scan","title":"<code>scan(text)</code>","text":"<p>Scan the given text and yield tokens as they are recognized.</p> Source code in <code>src/lectes/scanner/scanner.py</code> <pre><code>def scan(self, text: str) -&gt; Generator[Token]:\n    \"\"\"\n    Scan the given text and yield tokens as they are recognized.\n    \"\"\"\n    if len(text) == 0:\n        return\n\n    self.set_text(text)\n\n    for character in text:\n        self.logger().debug(f\"character: '{character}'\")\n\n        current_string = self.current_string()\n        self.logger().debug(f\"current_string: '{current_string}'\")\n\n        lookahead_string = self.lookahead_string()\n        self.logger().debug(f\"lookahead_string: '{lookahead_string}'\")\n\n        for rule in self.configuration.rules:\n            if not self._is_last_char() and rule.regex.fullmatch(lookahead_string):\n                self.logger().debug(\n                    f\"rule {rule.name} fullmatched lookahead_string: '{lookahead_string}'\"\n                )\n                break\n\n            if match := rule.regex.search(current_string):\n                self.logger().debug(\n                    f\"rule {rule.name} matched current_string: '{current_string}'\"\n                )\n                self._update_matched_state(rule, match)\n\n        if self._match is not None:\n            if self._match.unmatched is not None:\n                self._unmatched_handler(self._match.unmatched)\n\n            if self._matched_rule is not None:\n                result = self._matched_handlers[self._matched_rule](\n                    self._match.string, self._matched_rule\n                )\n\n                if result is not None:\n                    yield result\n\n            self.last_position = self.current_position\n\n        self.current_position += 1\n        self._reset_matched_state()\n</code></pre>"},{"location":"scanner/#lectes.scanner.scanner.Scanner.set_handler","title":"<code>set_handler(rule, handler)</code>","text":"<p>Set the given function as the handler that executes when a string is matched against rule.</p> <p>The handler should receive the matched string literal and the rule as arguments.</p> Source code in <code>src/lectes/scanner/scanner.py</code> <pre><code>def set_handler(self, rule: Rule, handler: Callable[[str, Rule], Any]) -&gt; None:\n    \"\"\"\n    Set the given function as the handler that executes when a string is matched\n    against rule.\n\n    The handler should receive the matched string literal and the rule as arguments.\n    \"\"\"\n    self._matched_handlers[rule] = handler\n</code></pre>"},{"location":"scanner/#lectes.scanner.scanner.Scanner.set_text","title":"<code>set_text(text)</code>","text":"<p>Set the text to scan.</p> Source code in <code>src/lectes/scanner/scanner.py</code> <pre><code>def set_text(self, text: str) -&gt; None:\n    \"\"\"\n    Set the text to scan.\n    \"\"\"\n    self.text = text\n    self.current_position = 1\n    self.last_position = 0\n</code></pre>"},{"location":"scanner/#lectes.scanner.scanner.Scanner.set_unmatched_handler","title":"<code>set_unmatched_handler(handler)</code>","text":"<p>Set the given function as the handler that executes when a string is not matched to a configured rule.</p> <p>The handler receives the string as argument and does returns None.</p> Source code in <code>src/lectes/scanner/scanner.py</code> <pre><code>def set_unmatched_handler(self, handler: Callable[[str], None]) -&gt; None:\n    \"\"\"\n    Set the given function as the handler that executes when a string is not\n    matched to a configured rule.\n\n    The handler receives the string as argument and does returns None.\n    \"\"\"\n    self._unmatched_handler = handler\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#defining-the-scanning-rules","title":"Defining the scanning rules","text":"<p>You have to define a set of <code>Rule</code>s based on which the scanner will operate. A <code>Rule</code> is just a named regex pattern.</p> <pre><code>from lectes import Rule, Regex, Configuration\n\nconfig = Configuration(\n  [\n    Rule(name=\"FOR\", regex=Regex(\"for\")),\n    Rule(name=\"IN\", regex=Regex(\"in\")),\n    Rule(name=\"ID\", regex=Regex(\"[a-zA-Z_][a-zA-Z_0-9]*\")),\n    Rule(name=\"COLON\", regex=Regex(\":\")),\n    Rule(name=\"WHITESPACE\", regex=Regex(\"( )\")),\n  ]\n)\n</code></pre>"},{"location":"usage/#scanning","title":"Scanning","text":"<p>The scanner only requires a <code>Configuration</code> of <code>Rule</code>s to be initialized, it  can then scan any given text based on that configuration.</p> <pre><code>from lectes import Rule, Regex, Configuration, Scanner\n\nconfig = Configuration(\n  [\n    Rule(name=\"FOR\", regex=Regex(\"for\")),\n    Rule(name=\"IN\", regex=Regex(\"in\")),\n    Rule(name=\"ID\", regex=Regex(\"[a-zA-Z_][a-zA-Z_0-9]*\")),\n    Rule(name=\"COLON\", regex=Regex(\":\")),\n    Rule(name=\"WHITESPACE\", regex=Regex(\"( )\")),\n  ]\n)\n\nscanner = Scanner(config)\n\nfor token in scanner.scan(\"for var in array:\"):\n  print(token)\n</code></pre>"},{"location":"usage/#defining-custom-handlers","title":"Defining custom handlers","text":"<p>When a rule is matched, the default behaviour of the scanner is to yield a <code>Token</code> object. This behaviour can be tweaked by defining custom handlers for individual rules.</p> <pre><code>from lectes import Rule, Regex, Configuration, Scanner, Token\n\nconfig = Configuration(\n  [\n    Rule(name=\"FOR\", regex=Regex(\"for\")),\n    Rule(name=\"IN\", regex=Regex(\"in\")),\n    Rule(name=\"ID\", regex=Regex(\"[a-zA-Z_][a-zA-Z_0-9]*\")),\n    Rule(name=\"COLON\", regex=Regex(\":\")),\n    Rule(name=\"WHITESPACE\", regex=Regex(\"( )\")),\n  ]\n)\n\ndef whitespace_handler(matched, rule):\n  return\n\nids = []\n\ndef id_handler(matched, rule):\n  ids.append(matched)\n  return Token(rule=rule, literal=matched)\n\n# You don't have to return a Token\ndef for_handler(matched, rule):\n  return {\"matched\": matched, \"rule\": rule}\n\nscanner = Scanner(config)\nscanner.set_handler(config.rules[0], for_handler)\nscanner.set_handler(config.rules[2], id_handler)\nscanner.set_handler(config.rules[4], whitespace_handler)\n\nfor token in scanner.scan(\"for var in array:\"):\n  print(token)\n\nprint(ids)\n</code></pre>"},{"location":"usage/#handling-unmatched-text","title":"Handling unmatched text","text":"<p>The default behaviour of the scanner is to print the text that does not match any rule. The default behaviour can be changed by defining a custom handler for unmatched text.</p> <pre><code>unmatched_text = []\n\ndef handler(unmatched: str) -&gt; None:\n  unmatched_text.append(unmatched)\n\nscanner.set_unmatched_handler(handler)\n</code></pre>"},{"location":"usage/#debugging","title":"Debugging","text":"<p>The <code>debug</code> argument can be passed in order to print debug logs while scanning.</p> <pre><code>scanner = Scanner(config, debug=True)\n</code></pre> <p>If the scanner has already been initialized without the debug flag, the log level can also be set to <code>DEBUG</code> by accessing the scanner's logger.</p> <pre><code>from lectes import LogLevel\n\nscanner.logger().set_level(LogLevel.DEBUG)\n</code></pre>"}]}